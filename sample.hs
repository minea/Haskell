[ x * x | x <- [ 1..10 ], even, x] --教科書54p
[1,2,3] ++ [4,5]
concat [[1,2],[],[3,2,1]]
length [1..10] -- 個数
head [1,2,3] -- 頭を取ってくる
tail[1,2,3] -- head以外を取ってくる
init[1,2,3] -- 一番最後の値以外を取ってくる
last[1,2,3] -- 一番最後のみを取ってくる
take 3 [1,2,3] --始めから第1引数で指定した数だけ取ってる
drop 3 [1..10] --始めから第1引数で指定した数以降の文字を取ってくる
takeWhile even [2,4,6,1,5,6] --even(偶数)を取得する(重複なし)
filter even [2,4,6,1,5,6] --even(偶数)を取得する(重複あり)
reverse [2,4,6] -- 配列を逆順にして出力
zip [0..4] "hallo" -- 2つ以上のリストの一文字目からのペアを取得する
unzip it -- zipしたものを本の組み合わせに戻す

(+) 1 3 == 4
(1+) 3 == 4
map (1+) [1..3] == [2,3,4]
map (2*) [1..3] == [2,4,6]
map (^3) [1..3] == [1,8,27]
sum [1..3] == 6
(sum . map (^3)) [1..3]
{- sum (map (^3) [1..3]) と等しい。合成関数((f・g)x)。
右の式から処理する。まず、map(g([1..3])をしてsum(f([1..3])をする -}
foldr (+) 0 [1..3] -- 1+(2+(3+0))
{- 以下の式と似ている
   s = 0;
   for(i = 1; i <= 3; i++){
         s += i;
   }
-}
foldl (+) 0 [1..3] -- ((0+1)+2)+3
foldl (-) 0 [1..3] -- ((0-1)-2)-3 == -6
foldr (-) 0 [1..3] -- 1-(2-(3-0)) == 2

scanl (+) 0 [1..3] == [0,1,3,6] -- それまでの累積和を表示
foldl (+) 0 [1..3] == 6
scanl (+) 0 [1..4] == [0,1,3,6,10] -- それまでの累積和を表示
foldl (+) 0 [1..4] == 10

inits [1..3] -- 先頭になりうる集合の列挙
tails [1..3] -- 後尾になりうる集合の列挙

map tails (inits [1..3]) == [],[1], [1,2],[2],[1,2,3],[2,3],[3] 
-- リストの全ての部分列の集合を列挙

-- 最大部分列和の求め方
[31,-41,59,26,-53,58, 97, -93, -23 ,84] -- 求めるリストの設定
inits it
map tails it -- ここまでで部分集合を求める
concat it -- 部分集合での空集合などを処理
map sum it -- 部分集合各位の合計を出す
foldr max (-1000) it -- -1000を下限として最大要素をリストから探す

